package traductorpascalc;
import java_cup.runtime.*;
import java.util.Map.Entry;

parser code{:
	public void syntax_error(String string, Symbol s){
		System.out.println(string + "Error localizado antes de: Linea "+s.left+" Columna "+s.right); 
	}
	public void unrecovered_syntax_error(String string, Symbol s){ 
                System.out.println("ERROR FATAL: " + string + "Error localizado antes de: Linea "+s.left+" Columna "+s.right); 
        }	
:}

non terminal PRG;
non terminal Blq BLQ;
non terminal DcList DCLLIST;
non terminal SentList SENTLIST;

non terminal Def DCL;
non terminal DefCte DEFCTE;
non terminal CteList CTELIST;
non terminal Constantes SIMPVALUE;
non terminal DefVar DEFVAR;
non terminal DefVarList DEFVARLIST;
non terminal VarList VARLIST;
non terminal DefProc DEFPROC;
non terminal DefFun DEFFUN;
non terminal FormalParamList FORMAL_PARAMLIST;
non terminal FormalParam FORMAL_PARAM;
non terminal Tipo TBAS;

non terminal Sent SENT;
non terminal INC;
non terminal Asig ASIG;
non terminal Id ID;
non terminal Exp EXP;
non terminal Op OP;
non terminal Operadores OPARIT;
non terminal Factor FACTOR;
non terminal SubPparamList SUBPPARAMLIST;
non terminal ExpList EXPLIST;
non terminal ProcCall PROC_CALL;

non terminal EXPCOND;
non terminal OPLOG;
non terminal FACTORCOND;
non terminal OPCOMP;


terminal String program_, identifier,numeric_integer_const,  numeric_real_const, 
    string_const, puntoComa, punto, begin_, end_, igual, procedure_, 
    function_, dosPuntos, abrirPar, cerrarPar, mas_, menos, 
    mul, div_, mod_, coma, puntosIgual, and_, or_, unit_, const_, var_, int_, 
    real_, if_, then_, else_, while_, do_, repeat_, until_, for_, downto_, to_, 
    not_, menor, mayor, menorIgual, mayorIgual;

precedence left mas_, menos;
precedence left mul, div_, and_, or_, mod_;

start with PRG;

PRG ::= program_ identifier:id puntoComa BLQ:b punto {:
        
        RESULT = b.cab + "void main (void) \n{\n" + b.valor + b.cierre;
        System.out.println("RESULT:\n"+RESULT);

        System.out.println("funcionaAA");
:} 
        | unit_ identifier puntoComa DCLLIST punto ;

BLQ ::= DCLLIST:dList begin_ SENTLIST:sList end_ {:
        RESULT = new Blq();
        
        RESULT.cab = dList.valor;
        RESULT.cierre = "}";
        RESULT.valor = sList.valor;
:};
DCLLIST ::= {:
        RESULT = new DcList();
        RESULT.valor = "";
:}  | DCLLIST:dList DCL:d {: 
        RESULT = new DcList();
        RESULT.valor = dList.valor + d.valor;
:};
SENTLIST ::= SENT:s{:
        RESULT = new SentList();
        RESULT.valor = s.valor;
:}  | SENTLIST:sList SENT:s {:
        RESULT = new SentList();
        RESULT.valor = sList.valor + s.valor;
:};

DCL ::= DEFCTE:dCte {:
        RESULT = new Def();
        RESULT.valor = dCte.valor;
:}  | DEFVAR:dVar{:
        RESULT = new Def();
        RESULT.valor = dVar.valor;
:}  | DEFPROC:dProc{:
        RESULT = new Def();
        RESULT.valor = dProc.valor;
:}  | DEFFUN:dFun{:
        RESULT = new Def();
        RESULT.valor = dFun.valor;
:};
DEFCTE ::= const_ CTELIST:cList {:
        RESULT = new DefCte();
        RESULT.valor = cList.valor;
:};
CTELIST ::= identifier:id igual SIMPVALUE:sv puntoComa {:
        RESULT = new CteList();
        RESULT.valor = "#define " + id + " " + sv +"; \n";
:}  | CTELIST:cList identifier:id igual SIMPVALUE:sv puntoComa {:
        RESULT = new CteList();
        RESULT.valor = cList.valor + "#define " + id + " " + sv + "; \n"; 
:};
SIMPVALUE ::= numeric_integer_const:nic {:
        RESULT = new Constantes();
        RESULT.valor = nic;
:}  | numeric_real_const:nrc {:
        RESULT = new Constantes();
        RESULT.valor = nrc;
:}  | string_const:sc {:
        RESULT = new Constantes();
        RESULT.valor = sc;
:};
DEFVAR ::= var_:var DEFVARLIST:dvList puntoComa {:
        RESULT = new DefVar();
        RESULT.valor = dvList.cab + " " + var + dvList.valor + ";\n" ;
:};
DEFVARLIST ::= VARLIST:vList dosPuntos TBAS:t {:
        RESULT = new DefVarList();
        RESULT.valor = vList.valor;
        RESULT.cab = t.valor;
:}  | DEFVARLIST:dvList puntoComa VARLIST:vList dosPuntos TBAS:t {:
        RESULT = new DefVarList();
        RESULT.valor = dvList.valor + ";\n" + t.valor+ " " + vList.valor ;
        RESULT.cab = dvList.cab;
:};
VARLIST ::= identifier:id {:
        RESULT = new VarList();
        RESULT.valor = id;
:}  | identifier:id coma VARLIST:vList {:
        RESULT = new VarList();
        RESULT.valor = id + ", " + vList.valor;
:};
DEFPROC ::= procedure_ identifier:id FORMAL_PARAMLIST:fpList puntoComa BLQ:b puntoComa {:
        RESULT = new DefProc();
        RESULT.valor = b.cab + "\n void " + id + fpList.valor + "\n" + b.valor;
:};
DEFFUN ::= function_ identifier:id FORMAL_PARAMLIST:fp dosPuntos TBAS:t puntoComa BLQ:b puntoComa {:
        RESULT = new DefFun();
        RESULT.valor = b.cab + "\n" + t.valor + id + fp.valor + b.valor;
:};
FORMAL_PARAMLIST ::= {:
        RESULT = new FormalParamList();
        RESULT.valor = "( void )";
:}  | abrirPar FORMAL_PARAM:fp cerrarPar {:
        RESULT = new FormalParamList();
        RESULT.valor = "("+fp.valor+")";
:};
FORMAL_PARAM ::= VARLIST:vList dosPuntos TBAS:t {:
        RESULT = new FormalParam();
        RESULT.valor = t.valor + " " + vList.valor;
:}  | VARLIST:vList dosPuntos TBAS:t puntoComa FORMAL_PARAM:fp {:
        RESULT = new FormalParam();
        RESULT.valor = t.valor + vList.valor + ", " + fp.valor;
:};
TBAS ::= int_ {:
        RESULT = new Tipo();
        RESULT.valor = "int";        
:}  | real_ {:
        RESULT = new Tipo();
        RESULT.valor = "float";        
:};

SENT ::= ASIG:a puntoComa{:
        RESULT = new Sent();
        RESULT.valor = a.valor + "; \n";
:}  | PROC_CALL:pc puntoComa{:
        RESULT = new Sent();
        RESULT.valor = pc.valor + ";" ;
:} | if_ EXPCOND then_ BLQ else_ BLQ
        | while_ EXPCOND do_ BLQ
        | repeat_ BLQ until_ EXPCOND puntoComa
        | for_ identifier puntosIgual EXP INC EXP do_ BLQ ; 
INC ::= to_ | downto_ ;
ASIG ::= ID:id puntosIgual:p EXP:e{:
        RESULT = new Asig();
        RESULT.valor = id.valor + " = " + e.valor;
:} ;
ID ::= identifier:id{:
        RESULT=new Id();
        RESULT.valor=id;
:} ;
EXP ::= EXP:e1 OP:o EXP:e2 {:
        RESULT = new Exp();
        RESULT.valor = e1.valor + o.valor + e2.valor; 
:}  | FACTOR:f {:
        RESULT = new Exp();
        RESULT.valor = f.valor; 
:};
OP ::= OPARIT:op{:
        RESULT = new Op();
        RESULT.valor = op.valor;
:};
OPARIT ::= mas_{:
        RESULT = new Operadores();
        RESULT.valor = "+ ";
:} | menos{:
        RESULT = new Operadores();
        RESULT.valor = "- ";
:} | mul{:
        RESULT = new Operadores();
        RESULT.valor = "* ";
:} | div_{:
        RESULT = new Operadores();
        RESULT.valor = "/ ";
:} | mod_{:
        RESULT = new Operadores();
        RESULT.valor = "%";
:} ;
FACTOR ::= SIMPVALUE:sv {:
        RESULT=new Factor();
        RESULT.valor= sv.valor; 
:}  | abrirPar EXP:e cerrarPar {:
        RESULT=new Factor();
        RESULT.valor = "(" + e.valor + ")"; 
:}  | identifier:id SUBPPARAMLIST:sublist {:
        RESULT=new Factor();
        RESULT.valor = id + sublist.valor; 
:};
SUBPPARAMLIST ::= {:
        RESULT = new SubPparamList();
        RESULT.valor = " ";
:}  | abrirPar EXPLIST:eList cerrarPar {:
        RESULT = new SubPparamList();
        RESULT.valor = "(" + eList.valor + ")";
:};
EXPLIST ::= EXP:e{:
        RESULT = new ExpList();
        RESULT.valor = e.valor;
:}  | EXP:e coma EXPLIST:eList {:
        RESULT = new ExpList();
        RESULT.valor = e.valor + ", " + eList.valor;
:};
PROC_CALL ::= identifier:id SUBPPARAMLIST:subList {:
        RESULT = new ProcCall();
        if (subList.valor == " ")
            RESULT.valor = id + "()";
        else
            RESULT.valor = id + subList.valor;
:} ; 

EXPCOND ::= EXPCOND OPLOG EXPCOND | FACTORCOND ;
OPLOG ::= or_ | and_ ;
FACTORCOND ::= EXP OPCOMP EXP | abrirPar EXP cerrarPar | not_ FACTORCOND ;
OPCOMP ::= menor | mayor | menorIgual | mayorIgual | igual ;